// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Struct.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Struct_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Struct_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Struct_2eproto;
namespace Protocol {
class ActorInfo;
struct ActorInfoDefaultTypeInternal;
extern ActorInfoDefaultTypeInternal _ActorInfo_default_instance_;
class CpuInfo;
struct CpuInfoDefaultTypeInternal;
extern CpuInfoDefaultTypeInternal _CpuInfo_default_instance_;
class CreatureInfo;
struct CreatureInfoDefaultTypeInternal;
extern CreatureInfoDefaultTypeInternal _CreatureInfo_default_instance_;
class MyPlayerInfo;
struct MyPlayerInfoDefaultTypeInternal;
extern MyPlayerInfoDefaultTypeInternal _MyPlayerInfo_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PositionInfo;
struct PositionInfoDefaultTypeInternal;
extern PositionInfoDefaultTypeInternal _PositionInfo_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class StatInfo;
struct StatInfoDefaultTypeInternal;
extern StatInfoDefaultTypeInternal _StatInfo_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::ActorInfo* Arena::CreateMaybeMessage<::Protocol::ActorInfo>(Arena*);
template<> ::Protocol::CpuInfo* Arena::CreateMaybeMessage<::Protocol::CpuInfo>(Arena*);
template<> ::Protocol::CreatureInfo* Arena::CreateMaybeMessage<::Protocol::CreatureInfo>(Arena*);
template<> ::Protocol::MyPlayerInfo* Arena::CreateMaybeMessage<::Protocol::MyPlayerInfo>(Arena*);
template<> ::Protocol::PlayerInfo* Arena::CreateMaybeMessage<::Protocol::PlayerInfo>(Arena*);
template<> ::Protocol::PositionInfo* Arena::CreateMaybeMessage<::Protocol::PositionInfo>(Arena*);
template<> ::Protocol::RoomInfo* Arena::CreateMaybeMessage<::Protocol::RoomInfo>(Arena*);
template<> ::Protocol::StatInfo* Arena::CreateMaybeMessage<::Protocol::StatInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() override;
  explicit constexpr RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfo(const RoomInfo& from);
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomInfo* New() const final {
    return new RoomInfo();
  }

  RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.RoomInfo";
  }
  protected:
  explicit RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
    kMapIdFieldNumber = 2,
  };
  // int32 roomId = 1;
  void clear_roomid();
  ::PROTOBUF_NAMESPACE_ID::int32 roomid() const;
  void set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roomid() const;
  void _internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 mapId = 2;
  void clear_mapid();
  ::PROTOBUF_NAMESPACE_ID::int32 mapid() const;
  void set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mapid() const;
  void _internal_set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 roomid_;
  ::PROTOBUF_NAMESPACE_ID::int32 mapid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class StatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.StatInfo) */ {
 public:
  inline StatInfo() : StatInfo(nullptr) {}
  ~StatInfo() override;
  explicit constexpr StatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatInfo(const StatInfo& from);
  StatInfo(StatInfo&& from) noexcept
    : StatInfo() {
    *this = ::std::move(from);
  }

  inline StatInfo& operator=(const StatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatInfo& operator=(StatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatInfo* internal_default_instance() {
    return reinterpret_cast<const StatInfo*>(
               &_StatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StatInfo& a, StatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StatInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatInfo* New() const final {
    return new StatInfo();
  }

  StatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatInfo& from);
  void MergeFrom(const StatInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.StatInfo";
  }
  protected:
  explicit StatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kHpFieldNumber = 2,
    kMaxHpFieldNumber = 3,
    kSpeedFieldNumber = 4,
    kAttackFieldNumber = 5,
    kDefenceFieldNumber = 6,
    kExpFieldNumber = 7,
    kTotalExpFieldNumber = 8,
  };
  // int32 level = 1;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 hp = 2;
  void clear_hp();
  ::PROTOBUF_NAMESPACE_ID::int32 hp() const;
  void set_hp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hp() const;
  void _internal_set_hp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 maxHp = 3;
  void clear_maxhp();
  ::PROTOBUF_NAMESPACE_ID::int32 maxhp() const;
  void set_maxhp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxhp() const;
  void _internal_set_maxhp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float speed = 4;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // int32 attack = 5;
  void clear_attack();
  ::PROTOBUF_NAMESPACE_ID::int32 attack() const;
  void set_attack(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attack() const;
  void _internal_set_attack(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 defence = 6;
  void clear_defence();
  ::PROTOBUF_NAMESPACE_ID::int32 defence() const;
  void set_defence(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_defence() const;
  void _internal_set_defence(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 exp = 7;
  void clear_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 exp() const;
  void set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exp() const;
  void _internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 totalExp = 8;
  void clear_totalexp();
  ::PROTOBUF_NAMESPACE_ID::int32 totalexp() const;
  void set_totalexp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_totalexp() const;
  void _internal_set_totalexp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.StatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  ::PROTOBUF_NAMESPACE_ID::int32 hp_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxhp_;
  float speed_;
  ::PROTOBUF_NAMESPACE_ID::int32 attack_;
  ::PROTOBUF_NAMESPACE_ID::int32 defence_;
  ::PROTOBUF_NAMESPACE_ID::int32 exp_;
  ::PROTOBUF_NAMESPACE_ID::int32 totalexp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PositionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PositionInfo) */ {
 public:
  inline PositionInfo() : PositionInfo(nullptr) {}
  ~PositionInfo() override;
  explicit constexpr PositionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionInfo(const PositionInfo& from);
  PositionInfo(PositionInfo&& from) noexcept
    : PositionInfo() {
    *this = ::std::move(from);
  }

  inline PositionInfo& operator=(const PositionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionInfo& operator=(PositionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionInfo* internal_default_instance() {
    return reinterpret_cast<const PositionInfo*>(
               &_PositionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PositionInfo& a, PositionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PositionInfo* New() const final {
    return new PositionInfo();
  }

  PositionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PositionInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PositionInfo& from);
  void MergeFrom(const PositionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PositionInfo";
  }
  protected:
  explicit PositionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kMoveDirFieldNumber = 2,
    kPosXFieldNumber = 3,
    kPosYFieldNumber = 4,
  };
  // .Protocol.ActorState state = 1;
  void clear_state();
  ::Protocol::ActorState state() const;
  void set_state(::Protocol::ActorState value);
  private:
  ::Protocol::ActorState _internal_state() const;
  void _internal_set_state(::Protocol::ActorState value);
  public:

  // .Protocol.MoveDir moveDir = 2;
  void clear_movedir();
  ::Protocol::MoveDir movedir() const;
  void set_movedir(::Protocol::MoveDir value);
  private:
  ::Protocol::MoveDir _internal_movedir() const;
  void _internal_set_movedir(::Protocol::MoveDir value);
  public:

  // int32 posX = 3;
  void clear_posx();
  ::PROTOBUF_NAMESPACE_ID::int32 posx() const;
  void set_posx(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_posx() const;
  void _internal_set_posx(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 posY = 4;
  void clear_posy();
  ::PROTOBUF_NAMESPACE_ID::int32 posy() const;
  void set_posy(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_posy() const;
  void _internal_set_posy(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PositionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int state_;
  int movedir_;
  ::PROTOBUF_NAMESPACE_ID::int32 posx_;
  ::PROTOBUF_NAMESPACE_ID::int32 posy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ActorInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ActorInfo) */ {
 public:
  inline ActorInfo() : ActorInfo(nullptr) {}
  ~ActorInfo() override;
  explicit constexpr ActorInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActorInfo(const ActorInfo& from);
  ActorInfo(ActorInfo&& from) noexcept
    : ActorInfo() {
    *this = ::std::move(from);
  }

  inline ActorInfo& operator=(const ActorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorInfo& operator=(ActorInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActorInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActorInfo* internal_default_instance() {
    return reinterpret_cast<const ActorInfo*>(
               &_ActorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ActorInfo& a, ActorInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActorInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorInfo* New() const final {
    return new ActorInfo();
  }

  ActorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActorInfo& from);
  void MergeFrom(const ActorInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ActorInfo";
  }
  protected:
  explicit ActorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 2,
    kActorIdFieldNumber = 1,
  };
  // .Protocol.PositionInfo posInfo = 2;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // int32 actorId = 1;
  void clear_actorid();
  ::PROTOBUF_NAMESPACE_ID::int32 actorid() const;
  void set_actorid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_actorid() const;
  void _internal_set_actorid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ActorInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PositionInfo* posinfo_;
  ::PROTOBUF_NAMESPACE_ID::int32 actorid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class CreatureInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CreatureInfo) */ {
 public:
  inline CreatureInfo() : CreatureInfo(nullptr) {}
  ~CreatureInfo() override;
  explicit constexpr CreatureInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureInfo(const CreatureInfo& from);
  CreatureInfo(CreatureInfo&& from) noexcept
    : CreatureInfo() {
    *this = ::std::move(from);
  }

  inline CreatureInfo& operator=(const CreatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureInfo& operator=(CreatureInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureInfo* internal_default_instance() {
    return reinterpret_cast<const CreatureInfo*>(
               &_CreatureInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreatureInfo& a, CreatureInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatureInfo* New() const final {
    return new CreatureInfo();
  }

  CreatureInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatureInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreatureInfo& from);
  void MergeFrom(const CreatureInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CreatureInfo";
  }
  protected:
  explicit CreatureInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorInfoFieldNumber = 1,
    kStatInfoFieldNumber = 2,
    kStateFlagFieldNumber = 3,
  };
  // .Protocol.ActorInfo actorInfo = 1;
  bool has_actorinfo() const;
  private:
  bool _internal_has_actorinfo() const;
  public:
  void clear_actorinfo();
  const ::Protocol::ActorInfo& actorinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ActorInfo* release_actorinfo();
  ::Protocol::ActorInfo* mutable_actorinfo();
  void set_allocated_actorinfo(::Protocol::ActorInfo* actorinfo);
  private:
  const ::Protocol::ActorInfo& _internal_actorinfo() const;
  ::Protocol::ActorInfo* _internal_mutable_actorinfo();
  public:
  void unsafe_arena_set_allocated_actorinfo(
      ::Protocol::ActorInfo* actorinfo);
  ::Protocol::ActorInfo* unsafe_arena_release_actorinfo();

  // .Protocol.StatInfo statInfo = 2;
  bool has_statinfo() const;
  private:
  bool _internal_has_statinfo() const;
  public:
  void clear_statinfo();
  const ::Protocol::StatInfo& statinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::StatInfo* release_statinfo();
  ::Protocol::StatInfo* mutable_statinfo();
  void set_allocated_statinfo(::Protocol::StatInfo* statinfo);
  private:
  const ::Protocol::StatInfo& _internal_statinfo() const;
  ::Protocol::StatInfo* _internal_mutable_statinfo();
  public:
  void unsafe_arena_set_allocated_statinfo(
      ::Protocol::StatInfo* statinfo);
  ::Protocol::StatInfo* unsafe_arena_release_statinfo();

  // int32 stateFlag = 3;
  void clear_stateflag();
  ::PROTOBUF_NAMESPACE_ID::int32 stateflag() const;
  void set_stateflag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stateflag() const;
  void _internal_set_stateflag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CreatureInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ActorInfo* actorinfo_;
  ::Protocol::StatInfo* statinfo_;
  ::PROTOBUF_NAMESPACE_ID::int32 stateflag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit constexpr PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return new PlayerInfo();
  }

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kCreatureInfoFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Protocol.CreatureInfo creatureInfo = 1;
  bool has_creatureinfo() const;
  private:
  bool _internal_has_creatureinfo() const;
  public:
  void clear_creatureinfo();
  const ::Protocol::CreatureInfo& creatureinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::CreatureInfo* release_creatureinfo();
  ::Protocol::CreatureInfo* mutable_creatureinfo();
  void set_allocated_creatureinfo(::Protocol::CreatureInfo* creatureinfo);
  private:
  const ::Protocol::CreatureInfo& _internal_creatureinfo() const;
  ::Protocol::CreatureInfo* _internal_mutable_creatureinfo();
  public:
  void unsafe_arena_set_allocated_creatureinfo(
      ::Protocol::CreatureInfo* creatureinfo);
  ::Protocol::CreatureInfo* unsafe_arena_release_creatureinfo();

  // @@protoc_insertion_point(class_scope:Protocol.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Protocol::CreatureInfo* creatureinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class MyPlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MyPlayerInfo) */ {
 public:
  inline MyPlayerInfo() : MyPlayerInfo(nullptr) {}
  ~MyPlayerInfo() override;
  explicit constexpr MyPlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MyPlayerInfo(const MyPlayerInfo& from);
  MyPlayerInfo(MyPlayerInfo&& from) noexcept
    : MyPlayerInfo() {
    *this = ::std::move(from);
  }

  inline MyPlayerInfo& operator=(const MyPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyPlayerInfo& operator=(MyPlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyPlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyPlayerInfo* internal_default_instance() {
    return reinterpret_cast<const MyPlayerInfo*>(
               &_MyPlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MyPlayerInfo& a, MyPlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MyPlayerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyPlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MyPlayerInfo* New() const final {
    return new MyPlayerInfo();
  }

  MyPlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MyPlayerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MyPlayerInfo& from);
  void MergeFrom(const MyPlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyPlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MyPlayerInfo";
  }
  protected:
  explicit MyPlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 1,
    kBaseStatInfoFieldNumber = 2,
  };
  // .Protocol.PlayerInfo playerInfo = 1;
  bool has_playerinfo() const;
  private:
  bool _internal_has_playerinfo() const;
  public:
  void clear_playerinfo();
  const ::Protocol::PlayerInfo& playerinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PlayerInfo* release_playerinfo();
  ::Protocol::PlayerInfo* mutable_playerinfo();
  void set_allocated_playerinfo(::Protocol::PlayerInfo* playerinfo);
  private:
  const ::Protocol::PlayerInfo& _internal_playerinfo() const;
  ::Protocol::PlayerInfo* _internal_mutable_playerinfo();
  public:
  void unsafe_arena_set_allocated_playerinfo(
      ::Protocol::PlayerInfo* playerinfo);
  ::Protocol::PlayerInfo* unsafe_arena_release_playerinfo();

  // .Protocol.StatInfo baseStatInfo = 2;
  bool has_basestatinfo() const;
  private:
  bool _internal_has_basestatinfo() const;
  public:
  void clear_basestatinfo();
  const ::Protocol::StatInfo& basestatinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::StatInfo* release_basestatinfo();
  ::Protocol::StatInfo* mutable_basestatinfo();
  void set_allocated_basestatinfo(::Protocol::StatInfo* basestatinfo);
  private:
  const ::Protocol::StatInfo& _internal_basestatinfo() const;
  ::Protocol::StatInfo* _internal_mutable_basestatinfo();
  public:
  void unsafe_arena_set_allocated_basestatinfo(
      ::Protocol::StatInfo* basestatinfo);
  ::Protocol::StatInfo* unsafe_arena_release_basestatinfo();

  // @@protoc_insertion_point(class_scope:Protocol.MyPlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PlayerInfo* playerinfo_;
  ::Protocol::StatInfo* basestatinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class CpuInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CpuInfo) */ {
 public:
  inline CpuInfo() : CpuInfo(nullptr) {}
  ~CpuInfo() override;
  explicit constexpr CpuInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CpuInfo(const CpuInfo& from);
  CpuInfo(CpuInfo&& from) noexcept
    : CpuInfo() {
    *this = ::std::move(from);
  }

  inline CpuInfo& operator=(const CpuInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpuInfo& operator=(CpuInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpuInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CpuInfo* internal_default_instance() {
    return reinterpret_cast<const CpuInfo*>(
               &_CpuInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CpuInfo& a, CpuInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CpuInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpuInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CpuInfo* New() const final {
    return new CpuInfo();
  }

  CpuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CpuInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CpuInfo& from);
  void MergeFrom(const CpuInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CpuInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CpuInfo";
  }
  protected:
  explicit CpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerNameFieldNumber = 4,
    kServerTypeFieldNumber = 1,
    kCpuUsageFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string serverName = 4;
  void clear_servername();
  const std::string& servername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servername();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_servername();
  void set_allocated_servername(std::string* servername);
  private:
  const std::string& _internal_servername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servername(const std::string& value);
  std::string* _internal_mutable_servername();
  public:

  // .Protocol.ServerType serverType = 1;
  void clear_servertype();
  ::Protocol::ServerType servertype() const;
  void set_servertype(::Protocol::ServerType value);
  private:
  ::Protocol::ServerType _internal_servertype() const;
  void _internal_set_servertype(::Protocol::ServerType value);
  public:

  // float cpuUsage = 2;
  void clear_cpuusage();
  float cpuusage() const;
  void set_cpuusage(float value);
  private:
  float _internal_cpuusage() const;
  void _internal_set_cpuusage(float value);
  public:

  // int64 timestamp = 3;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CpuInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servername_;
  int servertype_;
  float cpuusage_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoomInfo

// int32 roomId = 1;
inline void RoomInfo::clear_roomid() {
  roomid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomInfo::_internal_roomid() const {
  return roomid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.roomId)
  return _internal_roomid();
}
inline void RoomInfo::_internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  roomid_ = value;
}
inline void RoomInfo::set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.roomId)
}

// int32 mapId = 2;
inline void RoomInfo::clear_mapid() {
  mapid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomInfo::_internal_mapid() const {
  return mapid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomInfo::mapid() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.mapId)
  return _internal_mapid();
}
inline void RoomInfo::_internal_set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  mapid_ = value;
}
inline void RoomInfo::set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.mapId)
}

// -------------------------------------------------------------------

// StatInfo

// int32 level = 1;
inline void StatInfo::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.level)
  return _internal_level();
}
inline void StatInfo::_internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
}
inline void StatInfo::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.level)
}

// int32 hp = 2;
inline void StatInfo::clear_hp() {
  hp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::_internal_hp() const {
  return hp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.hp)
  return _internal_hp();
}
inline void StatInfo::_internal_set_hp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hp_ = value;
}
inline void StatInfo::set_hp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.hp)
}

// int32 maxHp = 3;
inline void StatInfo::clear_maxhp() {
  maxhp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::_internal_maxhp() const {
  return maxhp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.maxHp)
  return _internal_maxhp();
}
inline void StatInfo::_internal_set_maxhp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxhp_ = value;
}
inline void StatInfo::set_maxhp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.maxHp)
}

// float speed = 4;
inline void StatInfo::clear_speed() {
  speed_ = 0;
}
inline float StatInfo::_internal_speed() const {
  return speed_;
}
inline float StatInfo::speed() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.speed)
  return _internal_speed();
}
inline void StatInfo::_internal_set_speed(float value) {
  
  speed_ = value;
}
inline void StatInfo::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.speed)
}

// int32 attack = 5;
inline void StatInfo::clear_attack() {
  attack_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::_internal_attack() const {
  return attack_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::attack() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.attack)
  return _internal_attack();
}
inline void StatInfo::_internal_set_attack(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attack_ = value;
}
inline void StatInfo::set_attack(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attack(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.attack)
}

// int32 defence = 6;
inline void StatInfo::clear_defence() {
  defence_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::_internal_defence() const {
  return defence_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::defence() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.defence)
  return _internal_defence();
}
inline void StatInfo::_internal_set_defence(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  defence_ = value;
}
inline void StatInfo::set_defence(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_defence(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.defence)
}

// int32 exp = 7;
inline void StatInfo::clear_exp() {
  exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::_internal_exp() const {
  return exp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.exp)
  return _internal_exp();
}
inline void StatInfo::_internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exp_ = value;
}
inline void StatInfo::set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.exp)
}

// int32 totalExp = 8;
inline void StatInfo::clear_totalexp() {
  totalexp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::_internal_totalexp() const {
  return totalexp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatInfo::totalexp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.totalExp)
  return _internal_totalexp();
}
inline void StatInfo::_internal_set_totalexp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  totalexp_ = value;
}
inline void StatInfo::set_totalexp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_totalexp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.totalExp)
}

// -------------------------------------------------------------------

// PositionInfo

// .Protocol.ActorState state = 1;
inline void PositionInfo::clear_state() {
  state_ = 0;
}
inline ::Protocol::ActorState PositionInfo::_internal_state() const {
  return static_cast< ::Protocol::ActorState >(state_);
}
inline ::Protocol::ActorState PositionInfo::state() const {
  // @@protoc_insertion_point(field_get:Protocol.PositionInfo.state)
  return _internal_state();
}
inline void PositionInfo::_internal_set_state(::Protocol::ActorState value) {
  
  state_ = value;
}
inline void PositionInfo::set_state(::Protocol::ActorState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.PositionInfo.state)
}

// .Protocol.MoveDir moveDir = 2;
inline void PositionInfo::clear_movedir() {
  movedir_ = 0;
}
inline ::Protocol::MoveDir PositionInfo::_internal_movedir() const {
  return static_cast< ::Protocol::MoveDir >(movedir_);
}
inline ::Protocol::MoveDir PositionInfo::movedir() const {
  // @@protoc_insertion_point(field_get:Protocol.PositionInfo.moveDir)
  return _internal_movedir();
}
inline void PositionInfo::_internal_set_movedir(::Protocol::MoveDir value) {
  
  movedir_ = value;
}
inline void PositionInfo::set_movedir(::Protocol::MoveDir value) {
  _internal_set_movedir(value);
  // @@protoc_insertion_point(field_set:Protocol.PositionInfo.moveDir)
}

// int32 posX = 3;
inline void PositionInfo::clear_posx() {
  posx_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PositionInfo::_internal_posx() const {
  return posx_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PositionInfo::posx() const {
  // @@protoc_insertion_point(field_get:Protocol.PositionInfo.posX)
  return _internal_posx();
}
inline void PositionInfo::_internal_set_posx(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  posx_ = value;
}
inline void PositionInfo::set_posx(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:Protocol.PositionInfo.posX)
}

// int32 posY = 4;
inline void PositionInfo::clear_posy() {
  posy_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PositionInfo::_internal_posy() const {
  return posy_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PositionInfo::posy() const {
  // @@protoc_insertion_point(field_get:Protocol.PositionInfo.posY)
  return _internal_posy();
}
inline void PositionInfo::_internal_set_posy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  posy_ = value;
}
inline void PositionInfo::set_posy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:Protocol.PositionInfo.posY)
}

// -------------------------------------------------------------------

// ActorInfo

// int32 actorId = 1;
inline void ActorInfo::clear_actorid() {
  actorid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActorInfo::_internal_actorid() const {
  return actorid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActorInfo::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.ActorInfo.actorId)
  return _internal_actorid();
}
inline void ActorInfo::_internal_set_actorid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  actorid_ = value;
}
inline void ActorInfo::set_actorid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.ActorInfo.actorId)
}

// .Protocol.PositionInfo posInfo = 2;
inline bool ActorInfo::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool ActorInfo::has_posinfo() const {
  return _internal_has_posinfo();
}
inline void ActorInfo::clear_posinfo() {
  if (GetArenaForAllocation() == nullptr && posinfo_ != nullptr) {
    delete posinfo_;
  }
  posinfo_ = nullptr;
}
inline const ::Protocol::PositionInfo& ActorInfo::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& ActorInfo::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.ActorInfo.posInfo)
  return _internal_posinfo();
}
inline void ActorInfo::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ActorInfo.posInfo)
}
inline ::Protocol::PositionInfo* ActorInfo::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = posinfo_;
  posinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PositionInfo* ActorInfo::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.ActorInfo.posInfo)
  
  ::Protocol::PositionInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* ActorInfo::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::Protocol::PositionInfo* ActorInfo::mutable_posinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.ActorInfo.posInfo)
  return _internal_mutable_posinfo();
}
inline void ActorInfo::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete posinfo_;
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::PositionInfo>::GetOwningArena(posinfo);
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ActorInfo.posInfo)
}

// -------------------------------------------------------------------

// CreatureInfo

// .Protocol.ActorInfo actorInfo = 1;
inline bool CreatureInfo::_internal_has_actorinfo() const {
  return this != internal_default_instance() && actorinfo_ != nullptr;
}
inline bool CreatureInfo::has_actorinfo() const {
  return _internal_has_actorinfo();
}
inline void CreatureInfo::clear_actorinfo() {
  if (GetArenaForAllocation() == nullptr && actorinfo_ != nullptr) {
    delete actorinfo_;
  }
  actorinfo_ = nullptr;
}
inline const ::Protocol::ActorInfo& CreatureInfo::_internal_actorinfo() const {
  const ::Protocol::ActorInfo* p = actorinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ActorInfo&>(
      ::Protocol::_ActorInfo_default_instance_);
}
inline const ::Protocol::ActorInfo& CreatureInfo::actorinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.CreatureInfo.actorInfo)
  return _internal_actorinfo();
}
inline void CreatureInfo::unsafe_arena_set_allocated_actorinfo(
    ::Protocol::ActorInfo* actorinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actorinfo_);
  }
  actorinfo_ = actorinfo;
  if (actorinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.CreatureInfo.actorInfo)
}
inline ::Protocol::ActorInfo* CreatureInfo::release_actorinfo() {
  
  ::Protocol::ActorInfo* temp = actorinfo_;
  actorinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ActorInfo* CreatureInfo::unsafe_arena_release_actorinfo() {
  // @@protoc_insertion_point(field_release:Protocol.CreatureInfo.actorInfo)
  
  ::Protocol::ActorInfo* temp = actorinfo_;
  actorinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ActorInfo* CreatureInfo::_internal_mutable_actorinfo() {
  
  if (actorinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ActorInfo>(GetArenaForAllocation());
    actorinfo_ = p;
  }
  return actorinfo_;
}
inline ::Protocol::ActorInfo* CreatureInfo::mutable_actorinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.CreatureInfo.actorInfo)
  return _internal_mutable_actorinfo();
}
inline void CreatureInfo::set_allocated_actorinfo(::Protocol::ActorInfo* actorinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete actorinfo_;
  }
  if (actorinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::ActorInfo>::GetOwningArena(actorinfo);
    if (message_arena != submessage_arena) {
      actorinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actorinfo, submessage_arena);
    }
    
  } else {
    
  }
  actorinfo_ = actorinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.CreatureInfo.actorInfo)
}

// .Protocol.StatInfo statInfo = 2;
inline bool CreatureInfo::_internal_has_statinfo() const {
  return this != internal_default_instance() && statinfo_ != nullptr;
}
inline bool CreatureInfo::has_statinfo() const {
  return _internal_has_statinfo();
}
inline void CreatureInfo::clear_statinfo() {
  if (GetArenaForAllocation() == nullptr && statinfo_ != nullptr) {
    delete statinfo_;
  }
  statinfo_ = nullptr;
}
inline const ::Protocol::StatInfo& CreatureInfo::_internal_statinfo() const {
  const ::Protocol::StatInfo* p = statinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& CreatureInfo::statinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.CreatureInfo.statInfo)
  return _internal_statinfo();
}
inline void CreatureInfo::unsafe_arena_set_allocated_statinfo(
    ::Protocol::StatInfo* statinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statinfo_);
  }
  statinfo_ = statinfo;
  if (statinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.CreatureInfo.statInfo)
}
inline ::Protocol::StatInfo* CreatureInfo::release_statinfo() {
  
  ::Protocol::StatInfo* temp = statinfo_;
  statinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::StatInfo* CreatureInfo::unsafe_arena_release_statinfo() {
  // @@protoc_insertion_point(field_release:Protocol.CreatureInfo.statInfo)
  
  ::Protocol::StatInfo* temp = statinfo_;
  statinfo_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* CreatureInfo::_internal_mutable_statinfo() {
  
  if (statinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    statinfo_ = p;
  }
  return statinfo_;
}
inline ::Protocol::StatInfo* CreatureInfo::mutable_statinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.CreatureInfo.statInfo)
  return _internal_mutable_statinfo();
}
inline void CreatureInfo::set_allocated_statinfo(::Protocol::StatInfo* statinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete statinfo_;
  }
  if (statinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::StatInfo>::GetOwningArena(statinfo);
    if (message_arena != submessage_arena) {
      statinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statinfo, submessage_arena);
    }
    
  } else {
    
  }
  statinfo_ = statinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.CreatureInfo.statInfo)
}

// int32 stateFlag = 3;
inline void CreatureInfo::clear_stateflag() {
  stateflag_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreatureInfo::_internal_stateflag() const {
  return stateflag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreatureInfo::stateflag() const {
  // @@protoc_insertion_point(field_get:Protocol.CreatureInfo.stateFlag)
  return _internal_stateflag();
}
inline void CreatureInfo::_internal_set_stateflag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  stateflag_ = value;
}
inline void CreatureInfo::set_stateflag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stateflag(value);
  // @@protoc_insertion_point(field_set:Protocol.CreatureInfo.stateFlag)
}

// -------------------------------------------------------------------

// PlayerInfo

// .Protocol.CreatureInfo creatureInfo = 1;
inline bool PlayerInfo::_internal_has_creatureinfo() const {
  return this != internal_default_instance() && creatureinfo_ != nullptr;
}
inline bool PlayerInfo::has_creatureinfo() const {
  return _internal_has_creatureinfo();
}
inline void PlayerInfo::clear_creatureinfo() {
  if (GetArenaForAllocation() == nullptr && creatureinfo_ != nullptr) {
    delete creatureinfo_;
  }
  creatureinfo_ = nullptr;
}
inline const ::Protocol::CreatureInfo& PlayerInfo::_internal_creatureinfo() const {
  const ::Protocol::CreatureInfo* p = creatureinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::CreatureInfo&>(
      ::Protocol::_CreatureInfo_default_instance_);
}
inline const ::Protocol::CreatureInfo& PlayerInfo::creatureinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.creatureInfo)
  return _internal_creatureinfo();
}
inline void PlayerInfo::unsafe_arena_set_allocated_creatureinfo(
    ::Protocol::CreatureInfo* creatureinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creatureinfo_);
  }
  creatureinfo_ = creatureinfo;
  if (creatureinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.creatureInfo)
}
inline ::Protocol::CreatureInfo* PlayerInfo::release_creatureinfo() {
  
  ::Protocol::CreatureInfo* temp = creatureinfo_;
  creatureinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::CreatureInfo* PlayerInfo::unsafe_arena_release_creatureinfo() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.creatureInfo)
  
  ::Protocol::CreatureInfo* temp = creatureinfo_;
  creatureinfo_ = nullptr;
  return temp;
}
inline ::Protocol::CreatureInfo* PlayerInfo::_internal_mutable_creatureinfo() {
  
  if (creatureinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::CreatureInfo>(GetArenaForAllocation());
    creatureinfo_ = p;
  }
  return creatureinfo_;
}
inline ::Protocol::CreatureInfo* PlayerInfo::mutable_creatureinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.creatureInfo)
  return _internal_mutable_creatureinfo();
}
inline void PlayerInfo::set_allocated_creatureinfo(::Protocol::CreatureInfo* creatureinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete creatureinfo_;
  }
  if (creatureinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::CreatureInfo>::GetOwningArena(creatureinfo);
    if (message_arena != submessage_arena) {
      creatureinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creatureinfo, submessage_arena);
    }
    
  } else {
    
  }
  creatureinfo_ = creatureinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.creatureInfo)
}

// string name = 2;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.name)
}
inline std::string* PlayerInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.name)
  return _internal_mutable_name();
}
inline const std::string& PlayerInfo::_internal_name() const {
  return name_.Get();
}
inline void PlayerInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlayerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.name)
}

// -------------------------------------------------------------------

// MyPlayerInfo

// .Protocol.PlayerInfo playerInfo = 1;
inline bool MyPlayerInfo::_internal_has_playerinfo() const {
  return this != internal_default_instance() && playerinfo_ != nullptr;
}
inline bool MyPlayerInfo::has_playerinfo() const {
  return _internal_has_playerinfo();
}
inline void MyPlayerInfo::clear_playerinfo() {
  if (GetArenaForAllocation() == nullptr && playerinfo_ != nullptr) {
    delete playerinfo_;
  }
  playerinfo_ = nullptr;
}
inline const ::Protocol::PlayerInfo& MyPlayerInfo::_internal_playerinfo() const {
  const ::Protocol::PlayerInfo* p = playerinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& MyPlayerInfo::playerinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.MyPlayerInfo.playerInfo)
  return _internal_playerinfo();
}
inline void MyPlayerInfo::unsafe_arena_set_allocated_playerinfo(
    ::Protocol::PlayerInfo* playerinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerinfo_);
  }
  playerinfo_ = playerinfo;
  if (playerinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MyPlayerInfo.playerInfo)
}
inline ::Protocol::PlayerInfo* MyPlayerInfo::release_playerinfo() {
  
  ::Protocol::PlayerInfo* temp = playerinfo_;
  playerinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PlayerInfo* MyPlayerInfo::unsafe_arena_release_playerinfo() {
  // @@protoc_insertion_point(field_release:Protocol.MyPlayerInfo.playerInfo)
  
  ::Protocol::PlayerInfo* temp = playerinfo_;
  playerinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* MyPlayerInfo::_internal_mutable_playerinfo() {
  
  if (playerinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    playerinfo_ = p;
  }
  return playerinfo_;
}
inline ::Protocol::PlayerInfo* MyPlayerInfo::mutable_playerinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.MyPlayerInfo.playerInfo)
  return _internal_mutable_playerinfo();
}
inline void MyPlayerInfo::set_allocated_playerinfo(::Protocol::PlayerInfo* playerinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerinfo_;
  }
  if (playerinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::PlayerInfo>::GetOwningArena(playerinfo);
    if (message_arena != submessage_arena) {
      playerinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerinfo, submessage_arena);
    }
    
  } else {
    
  }
  playerinfo_ = playerinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MyPlayerInfo.playerInfo)
}

// .Protocol.StatInfo baseStatInfo = 2;
inline bool MyPlayerInfo::_internal_has_basestatinfo() const {
  return this != internal_default_instance() && basestatinfo_ != nullptr;
}
inline bool MyPlayerInfo::has_basestatinfo() const {
  return _internal_has_basestatinfo();
}
inline void MyPlayerInfo::clear_basestatinfo() {
  if (GetArenaForAllocation() == nullptr && basestatinfo_ != nullptr) {
    delete basestatinfo_;
  }
  basestatinfo_ = nullptr;
}
inline const ::Protocol::StatInfo& MyPlayerInfo::_internal_basestatinfo() const {
  const ::Protocol::StatInfo* p = basestatinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& MyPlayerInfo::basestatinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.MyPlayerInfo.baseStatInfo)
  return _internal_basestatinfo();
}
inline void MyPlayerInfo::unsafe_arena_set_allocated_basestatinfo(
    ::Protocol::StatInfo* basestatinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basestatinfo_);
  }
  basestatinfo_ = basestatinfo;
  if (basestatinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MyPlayerInfo.baseStatInfo)
}
inline ::Protocol::StatInfo* MyPlayerInfo::release_basestatinfo() {
  
  ::Protocol::StatInfo* temp = basestatinfo_;
  basestatinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::StatInfo* MyPlayerInfo::unsafe_arena_release_basestatinfo() {
  // @@protoc_insertion_point(field_release:Protocol.MyPlayerInfo.baseStatInfo)
  
  ::Protocol::StatInfo* temp = basestatinfo_;
  basestatinfo_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* MyPlayerInfo::_internal_mutable_basestatinfo() {
  
  if (basestatinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    basestatinfo_ = p;
  }
  return basestatinfo_;
}
inline ::Protocol::StatInfo* MyPlayerInfo::mutable_basestatinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.MyPlayerInfo.baseStatInfo)
  return _internal_mutable_basestatinfo();
}
inline void MyPlayerInfo::set_allocated_basestatinfo(::Protocol::StatInfo* basestatinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete basestatinfo_;
  }
  if (basestatinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Protocol::StatInfo>::GetOwningArena(basestatinfo);
    if (message_arena != submessage_arena) {
      basestatinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basestatinfo, submessage_arena);
    }
    
  } else {
    
  }
  basestatinfo_ = basestatinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MyPlayerInfo.baseStatInfo)
}

// -------------------------------------------------------------------

// CpuInfo

// .Protocol.ServerType serverType = 1;
inline void CpuInfo::clear_servertype() {
  servertype_ = 0;
}
inline ::Protocol::ServerType CpuInfo::_internal_servertype() const {
  return static_cast< ::Protocol::ServerType >(servertype_);
}
inline ::Protocol::ServerType CpuInfo::servertype() const {
  // @@protoc_insertion_point(field_get:Protocol.CpuInfo.serverType)
  return _internal_servertype();
}
inline void CpuInfo::_internal_set_servertype(::Protocol::ServerType value) {
  
  servertype_ = value;
}
inline void CpuInfo::set_servertype(::Protocol::ServerType value) {
  _internal_set_servertype(value);
  // @@protoc_insertion_point(field_set:Protocol.CpuInfo.serverType)
}

// float cpuUsage = 2;
inline void CpuInfo::clear_cpuusage() {
  cpuusage_ = 0;
}
inline float CpuInfo::_internal_cpuusage() const {
  return cpuusage_;
}
inline float CpuInfo::cpuusage() const {
  // @@protoc_insertion_point(field_get:Protocol.CpuInfo.cpuUsage)
  return _internal_cpuusage();
}
inline void CpuInfo::_internal_set_cpuusage(float value) {
  
  cpuusage_ = value;
}
inline void CpuInfo::set_cpuusage(float value) {
  _internal_set_cpuusage(value);
  // @@protoc_insertion_point(field_set:Protocol.CpuInfo.cpuUsage)
}

// int64 timestamp = 3;
inline void CpuInfo::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CpuInfo::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CpuInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:Protocol.CpuInfo.timestamp)
  return _internal_timestamp();
}
inline void CpuInfo::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void CpuInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Protocol.CpuInfo.timestamp)
}

// string serverName = 4;
inline void CpuInfo::clear_servername() {
  servername_.ClearToEmpty();
}
inline const std::string& CpuInfo::servername() const {
  // @@protoc_insertion_point(field_get:Protocol.CpuInfo.serverName)
  return _internal_servername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CpuInfo::set_servername(ArgT0&& arg0, ArgT... args) {
 
 servername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CpuInfo.serverName)
}
inline std::string* CpuInfo::mutable_servername() {
  // @@protoc_insertion_point(field_mutable:Protocol.CpuInfo.serverName)
  return _internal_mutable_servername();
}
inline const std::string& CpuInfo::_internal_servername() const {
  return servername_.Get();
}
inline void CpuInfo::_internal_set_servername(const std::string& value) {
  
  servername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CpuInfo::_internal_mutable_servername() {
  
  return servername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CpuInfo::release_servername() {
  // @@protoc_insertion_point(field_release:Protocol.CpuInfo.serverName)
  return servername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CpuInfo::set_allocated_servername(std::string* servername) {
  if (servername != nullptr) {
    
  } else {
    
  }
  servername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), servername,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.CpuInfo.serverName)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto
